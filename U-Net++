class U_NetPlusPlus(nn.Module):
    def __init__(self, img_ch=3, output_ch=1):
        super(U_NetPlusPlus, self).__init__()
        self.Maxpool = nn.MaxPool2d(kernel_size=2, stride=2)
        filters = [64, 128, 256, 512, 1024]  # 和原U-Net通道数完全一致

        # 编码层
        self.conv0_0 = conv_block(ch_in=img_ch, ch_out=filters[0])
        self.conv1_0 = conv_block(ch_in=filters[0], ch_out=filters[1])
        self.conv2_0 = conv_block(ch_in=filters[1], ch_out=filters[2])
        self.conv3_0 = conv_block(ch_in=filters[2], ch_out=filters[3])
        self.conv4_0 = conv_block(ch_in=filters[3], ch_out=filters[4])

        # 嵌套上采样+密集连接
        self.up1_0 = up_conv(ch_in=filters[1], ch_out=filters[0])
        self.conv0_1 = conv_block(ch_in=filters[0] * 2, ch_out=filters[0])

        self.up2_0 = up_conv(ch_in=filters[2], ch_out=filters[1])
        self.conv1_1 = conv_block(ch_in=filters[1] * 2, ch_out=filters[1])
        self.up1_1 = up_conv(ch_in=filters[1], ch_out=filters[0])
        self.conv0_2 = conv_block(ch_in=filters[0] * 3, ch_out=filters[0])

        self.up3_0 = up_conv(ch_in=filters[3], ch_out=filters[2])
        self.conv2_1 = conv_block(ch_in=filters[2] * 2, ch_out=filters[2])
        self.up2_1 = up_conv(ch_in=filters[2], ch_out=filters[1])
        self.conv1_2 = conv_block(ch_in=filters[1] * 3, ch_out=filters[1])
        self.up1_2 = up_conv(ch_in=filters[1], ch_out=filters[0])
        self.conv0_3 = conv_block(ch_in=filters[0] * 4, ch_out=filters[0])

        self.up4_0 = up_conv(ch_in=filters[4], ch_out=filters[3])
        self.conv3_1 = conv_block(ch_in=filters[3] * 2, ch_out=filters[3])
        self.up3_1 = up_conv(ch_in=filters[3], ch_out=filters[2])
        self.conv2_2 = conv_block(ch_in=filters[2] * 3, ch_out=filters[2])
        self.up2_2 = up_conv(ch_in=filters[2], ch_out=filters[1])
        self.conv1_3 = conv_block(ch_in=filters[1] * 4, ch_out=filters[1])
        self.up1_3 = up_conv(ch_in=filters[1], ch_out=filters[0])
        self.conv0_4 = conv_block(ch_in=filters[0] * 5, ch_out=filters[0])

        # 输出层 (和原U-Net完全一样)
        self.Conv_1x1 = nn.Conv2d(filters[0], output_ch, kernel_size=1, stride=1, padding=0)

    def forward(self, x):
        # 编码路径
        x0_0 = self.conv0_0(x)
        x1_0 = self.conv1_0(self.Maxpool(x0_0))
        x2_0 = self.conv2_0(self.Maxpool(x1_0))
        x3_0 = self.conv3_0(self.Maxpool(x2_0))
        x4_0 = self.conv4_0(self.Maxpool(x3_0))

        # 嵌套解码+密集拼接 【U-Net++核心】
        x0_1 = self.conv0_1(torch.cat([x0_0, self.up1_0(x1_0)], dim=1))

        x1_1 = self.conv1_1(torch.cat([x1_0, self.up2_0(x2_0)], dim=1))
        x0_2 = self.conv0_2(torch.cat([x0_0, x0_1, self.up1_1(x1_1)], dim=1))

        x2_1 = self.conv2_1(torch.cat([x2_0, self.up3_0(x3_0)], dim=1))
        x1_2 = self.conv1_2(torch.cat([x1_0, x1_1, self.up2_1(x2_1)], dim=1))
        x0_3 = self.conv0_3(torch.cat([x0_0, x0_1, x0_2, self.up1_2(x1_2)], dim=1))

        x3_1 = self.conv3_1(torch.cat([x3_0, self.up4_0(x4_0)], dim=1))
        x2_2 = self.conv2_2(torch.cat([x2_0, x2_1, self.up3_1(x3_1)], dim=1))
        x1_3 = self.conv1_3(torch.cat([x1_0, x1_1, x1_2, self.up2_2(x2_2)], dim=1))
        x0_4 = self.conv0_4(torch.cat([x0_0, x0_1, x0_2, x0_3, self.up1_3(x1_3)], dim=1))

        # 输出层
        out = self.Conv_1x1(x0_4)
        return out
